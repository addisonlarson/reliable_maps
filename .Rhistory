args = list(mean = bottom[1,]$pct, sd = bottom[1,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = secondary, alpha = 0.3,
args = list(mean = bottom[1,]$pct, sd = bottom[1,]$sd),
xlim = c(100 / 3, 100),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = secondary,
args = list(mean = bottom[2,]$pct, sd = bottom[2,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = secondary, alpha = 0.3,
args = list(mean = bottom[2,]$pct, sd = bottom[2,]$sd),
xlim = c(100 / 3, 100),
geom = "area") +
ylab("Probability") + xlab("Potential Value of Estimate") +
scale_y_continuous(breaks = NULL) +
ggtitle("Range of Possible Values for All Census Tracts") +
theme_minimal()
plot(p6)
# All estimates with boundaries and classification error
# Two estimates with class boundary and classification error
p6 <- ggplot(data = data.frame(x = c(-10, 110)), aes(x)) +
annotate("segment", x = 200 / 3, xend = 200 / 3, y = 0.2, yend = 0, color = "gray") +
annotate("segment", x = 100 / 3, xend = 100 / 3, y = 0.2, yend = 0, color = "gray") +
stat_function(fun = dnorm, n = 101, color = primary,
args = list(mean = top[1,]$pct, sd = top[1,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = primary, alpha = 0.5,
args = list(mean = top[1,]$pct, sd = top[1,]$sd),
xlim = c(0, 200 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = primary,
args = list(mean = top[2,]$pct, sd = top[2,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = primary, alpha = 0.5,
args = list(mean = top[2,]$pct, sd = top[2,]$sd),
xlim = c(0, 200 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = primary,
args = list(mean = top[3,]$pct, sd = top[3,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = primary, alpha = 0.5,
args = list(mean = top[3,]$pct, sd = top[3,]$sd),
xlim = c(0, 200 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = tertiary,
args = list(mean = middle[1,]$pct, sd = middle[1,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = tertiary, alpha = 0.5,
args = list(mean = middle[1,]$pct, sd = middle[1,]$sd),
xlim = c(0, 100 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, fill = tertiary, alpha = 0.5,
args = list(mean = middle[1,]$pct, sd = middle[1,]$sd),
xlim = c(200 / 3, 100),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = tertiary,
args = list(mean = middle[2,]$pct, sd = middle[2,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = tertiary, alpha = 0.5,
args = list(mean = middle[2,]$pct, sd = middle[2,]$sd),
xlim = c(0, 100 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, fill = tertiary, alpha = 0.5,
args = list(mean = middle[2,]$pct, sd = middle[2,]$sd),
xlim = c(200 / 3, 100),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = secondary,
args = list(mean = bottom[1,]$pct, sd = bottom[1,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = secondary, alpha = 0.5,
args = list(mean = bottom[1,]$pct, sd = bottom[1,]$sd),
xlim = c(100 / 3, 100),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = secondary,
args = list(mean = bottom[2,]$pct, sd = bottom[2,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = secondary, alpha = 0.5,
args = list(mean = bottom[2,]$pct, sd = bottom[2,]$sd),
xlim = c(100 / 3, 100),
geom = "area") +
ylab("Probability") + xlab("Potential Value of Estimate") +
scale_y_continuous(breaks = NULL) +
ggtitle("Range of Possible Values for All Census Tracts") +
theme_minimal()
plot(p6)
# All estimates with boundaries and classification error
# Two estimates with class boundary and classification error
p6 <- ggplot(data = data.frame(x = c(-10, 110)), aes(x)) +
annotate("segment", x = 200 / 3, xend = 200 / 3, y = 0.17, yend = 0, color = "gray") +
annotate("segment", x = 100 / 3, xend = 100 / 3, y = 0.17, yend = 0, color = "gray") +
stat_function(fun = dnorm, n = 101, color = primary,
args = list(mean = top[1,]$pct, sd = top[1,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = primary, alpha = 0.5,
args = list(mean = top[1,]$pct, sd = top[1,]$sd),
xlim = c(0, 200 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = primary,
args = list(mean = top[2,]$pct, sd = top[2,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = primary, alpha = 0.5,
args = list(mean = top[2,]$pct, sd = top[2,]$sd),
xlim = c(0, 200 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = primary,
args = list(mean = top[3,]$pct, sd = top[3,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = primary, alpha = 0.5,
args = list(mean = top[3,]$pct, sd = top[3,]$sd),
xlim = c(0, 200 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = tertiary,
args = list(mean = middle[1,]$pct, sd = middle[1,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = tertiary, alpha = 0.5,
args = list(mean = middle[1,]$pct, sd = middle[1,]$sd),
xlim = c(0, 100 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, fill = tertiary, alpha = 0.5,
args = list(mean = middle[1,]$pct, sd = middle[1,]$sd),
xlim = c(200 / 3, 100),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = tertiary,
args = list(mean = middle[2,]$pct, sd = middle[2,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = tertiary, alpha = 0.5,
args = list(mean = middle[2,]$pct, sd = middle[2,]$sd),
xlim = c(0, 100 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, fill = tertiary, alpha = 0.5,
args = list(mean = middle[2,]$pct, sd = middle[2,]$sd),
xlim = c(200 / 3, 100),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = secondary,
args = list(mean = bottom[1,]$pct, sd = bottom[1,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = secondary, alpha = 0.5,
args = list(mean = bottom[1,]$pct, sd = bottom[1,]$sd),
xlim = c(100 / 3, 100),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = secondary,
args = list(mean = bottom[2,]$pct, sd = bottom[2,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = secondary, alpha = 0.5,
args = list(mean = bottom[2,]$pct, sd = bottom[2,]$sd),
xlim = c(100 / 3, 100),
geom = "area") +
ylab("Probability") + xlab("Potential Value of Estimate") +
scale_y_continuous(breaks = NULL) +
ggtitle("Range of Possible Values for All Census Tracts") +
theme_minimal()
plot(p6)
# All estimates with boundaries and classification error
# Two estimates with class boundary and classification error
p6 <- ggplot(data = data.frame(x = c(-10, 110)), aes(x)) +
annotate("segment", x = 200 / 3, xend = 200 / 3, y = 0.18, yend = 0, color = "gray") +
annotate("segment", x = 100 / 3, xend = 100 / 3, y = 0.18, yend = 0, color = "gray") +
stat_function(fun = dnorm, n = 101, color = primary,
args = list(mean = top[1,]$pct, sd = top[1,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = primary, alpha = 0.5,
args = list(mean = top[1,]$pct, sd = top[1,]$sd),
xlim = c(0, 200 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = primary,
args = list(mean = top[2,]$pct, sd = top[2,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = primary, alpha = 0.5,
args = list(mean = top[2,]$pct, sd = top[2,]$sd),
xlim = c(0, 200 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = primary,
args = list(mean = top[3,]$pct, sd = top[3,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = primary, alpha = 0.5,
args = list(mean = top[3,]$pct, sd = top[3,]$sd),
xlim = c(0, 200 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = tertiary,
args = list(mean = middle[1,]$pct, sd = middle[1,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = tertiary, alpha = 0.5,
args = list(mean = middle[1,]$pct, sd = middle[1,]$sd),
xlim = c(0, 100 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, fill = tertiary, alpha = 0.5,
args = list(mean = middle[1,]$pct, sd = middle[1,]$sd),
xlim = c(200 / 3, 100),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = tertiary,
args = list(mean = middle[2,]$pct, sd = middle[2,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = tertiary, alpha = 0.5,
args = list(mean = middle[2,]$pct, sd = middle[2,]$sd),
xlim = c(0, 100 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, fill = tertiary, alpha = 0.5,
args = list(mean = middle[2,]$pct, sd = middle[2,]$sd),
xlim = c(200 / 3, 100),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = secondary,
args = list(mean = bottom[1,]$pct, sd = bottom[1,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = secondary, alpha = 0.5,
args = list(mean = bottom[1,]$pct, sd = bottom[1,]$sd),
xlim = c(100 / 3, 100),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = secondary,
args = list(mean = bottom[2,]$pct, sd = bottom[2,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = secondary, alpha = 0.5,
args = list(mean = bottom[2,]$pct, sd = bottom[2,]$sd),
xlim = c(100 / 3, 100),
geom = "area") +
ylab("Probability") + xlab("Potential Value of Estimate") +
scale_y_continuous(breaks = NULL) +
ggtitle("Range of Possible Values for All Census Tracts") +
theme_minimal()
plot(p6)
png(here("figures", "p6.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(p6)
dev.off()
library(sf); library(tidyverse); library(here); library(RColorBrewer)
library(sf); library(tidyverse); library(here); library(RColorBrewer)
library(sf); library(tidyverse); library(here); library(RColorBrewer)
url <- "https://data.cityofnewyork.us/api/geospatial/d3qk-pfyz?method=export&format=Shapefile"
download.file(url, here("downloads", "nta.zip"), mode = "wb")
unzip("nta.zip")
unzip(here("downloads", "nta.zip"))
nta <- st_read(here("downloads", "./nta.shp"))
nta <- st_read(here("downloads", "./geo_export_29ce9bf7-979a-4f24-b3ab-4207409cc354.shp"))
unzip(here("downloads", "nta.zip"))
st_read("D:/alarson/reliable_maps/downloads/./geo_export_29ce9bf7-979a-4f24-b3ab-4207409cc354.shp")
st_read("D:/alarson/reliable_maps/downloads/geo_export_29ce9bf7-979a-4f24-b3ab-4207409cc354.shp")
library(sf); library(tidyverse); library(here); library(RColorBrewer);library(rgdal)
url <- "https://data.cityofnewyork.us/api/geospatial/d3qk-pfyz?method=export&format=Shapefile"
download.file(url, here("downloads", "nta.zip"), mode = "wb")
unzip(here("downloads", "nta.zip"))
test <- st_read("url")
url <- "https://data.cityofnewyork.us/api/geospatial/d3qk-pfyz?method=export&format=Shapefile"
download.file(url, here("downloads", "nta.zip"), mode = "wb")
unzip(here("downloads", "nta.zip"))
?unzip
test <- st_read(here("downloads", "."))
url <- "https://data.cityofnewyork.us/api/geospatial/d3qk-pfyz?method=export&format=Shapefile"
download.file(url, here("downloads", "nta.zip"), mode = "wb")
unzip(here("downloads"))
unzip(here("downloads", "nta"))
unzip(here("downloads", "nta.zip"), here("downloads"))
download.file(url, here("downloads", "nta.zip"), mode = "wb")
unzip(here("downloads", "nta.zip"), here("downloads"))
here("downloads")
here()
url <- "https://data.cityofnewyork.us/api/geospatial/d3qk-pfyz?method=export&format=Shapefile"
download.file(url, here("downloads", "nta.zip"), mode = "wb")
unzip(here("downloads", "nta.zip"), here())
unzip(here(), here("downloads", "nta.zip"))
unzip(here("downloads", "nta.zip"))
unzip(here("downloads", "nta.zip"), exdir = here())
unzip(here("downloads", "nta.zip"), exdir = here("downloads"))
list.files(pattern = "*.shp")
?list.files
list.files(here("downloads"), pattern = "*.shp")
# Find NTA filename (changes with each DL)
file_id <- list.files(here("downloads"), pattern = "*.shp")
paste0("./", file_id)
nyc_nta <- st_read(here("downloads"), paste0("./", file_id))
# Find NTA filename (changes with each DL)
file_id <- paste0("./", list.files(here("downloads"), pattern = "*.shp"))
file_id
nyc_nta <- st_read(here("downloads"), paste0("./", file_id))
# Find NTA filename (changes with each DL)
file_id <- paste0("'./", list.files(here("downloads"), pattern = "*.shp"), "'")
nyc_nta <- st_read(here("downloads"), paste0("./", file_id))
# Find NTA filename (changes with each DL)
file_id <- list.files(here("downloads"), pattern = "*.shp")
file_id
nyc_nta <- st_read(here("downloads"), "./geo_export_be753f79-ee79-46f5-89d8-fa420dcea664.shp")
library(sf); library(tidyverse); library(here); library(RColorBrewer);library(rgdal)
# Download and unzip NTA file
url <- "https://data.cityofnewyork.us/api/geospatial/d3qk-pfyz?method=export&format=Shapefile"
download.file(url, here("downloads", "nta.zip"), mode = "wb")
unzip(here("downloads", "nta.zip"), exdir = here("downloads"))
# Find NTA filename (changes with each DL)
file_id <- list.files(here("downloads"), pattern = "*.shp")
file_id
nyc_nta <- st_read(here("downloads"), "./geo_export_24927704-edb8-45e9-9f86-6df9b893cd80.shp")
nyc_nta <- st_read(here("downloads"), "./ethn_orig_bg.shp")
nyc_nta <- st_read(here("outputs", "./ethn_orig_bg.shp"))
nyc_nta <- st_read(here("downloads", "./ethn_orig_bg.shp"))
file_id
nyc_nta <- st_read(here("downloads", "./geo_export_24927704-edb8-45e9-9f86-6df9b893cd80.shp"))
# Find NTA filename (changes with each DL)
file_id <- paste0("./", list.files(here("downloads"), pattern = "*.shp"))
# Find NTA filename (changes with each DL)
file_id <- paste0("./", list.files(here("downloads"), pattern = "*.shp"))
nyc_nta <- st_read(here("downloads", file_id))
plot(nyc_nta["shape_area"])
nyc_nta <- st_read(here("downloads", file_id)) %>%
plot(nyc_nta["ntaname"], border = NA, main = NULL)
nyc_nta <- st_read(here("downloads", file_id)) %>%
plot(nyc_nta["ntaname"])
nyc_nta <- st_read(here("downloads", file_id)) %>%
plot(nyc_nta["shape_area"])
nyc_nta <- st_read(here("downloads", file_id))
plot(nyc_nta["shape_area"])
plot(nyc_nta["ntaname"])
plot(nyc_nta["ntaname"],
pal = brewer.pal("Set3"))
plot(nyc_nta["ntaname"],
pal = brewer.pal(6, "Set3"))
plot(nyc_nta["ntaname"],
pal = brewer.pal(195, "Set3"))
plot(nyc_nta["ntaname"],
pal = brewer.pal(8, "Set3"))
unique(nyc_nta$borocode)
plot(nyc_nta["ntaname"],
pal = brewer.pal(5, "PuBu"),
border = NA, main = NULL)
plot(nyc_nta["ntaname"])
plot(nyc_nta["borocode"],
pal = brewer.pal(5, "PuBu"),
border = NA, main = NULL)
plot(nyc_nta["boroname"],
pal = brewer.pal(5, "PuBu"),
border = NA, main = NULL)
plot(nyc_nta["boroname"],
pal = brewer.pal(5, "PuBu"),
border = "white", main = NULL)
testpal <- palette(c(cc("black", "blue")))
testpal <- palette(c("black", "blue"))
plot(nyc_nta["boroname"],
pal = testpal,
border = "white", main = NULL)
yo <- c("#F3EEF3", "#BDC9DE", "#70A8D1", "#2B8DBC", "#04598F")
?rep_len
yo2 <- rep_len(yo, 195)
p <- rep_len(c("#F3EEF3", "#BDC9DE", "#70A8D1", "#2B8DBC", "#04598F"), 195)
pal <- palette(p)
mypal <- palette(p)
# png(here("figures", "nyc_nta.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(nyc_nta["ntaname"],
pal = mypal,
border = "white", main = NULL)
library(sf); library(tidyverse); library(here); library(RColorBrewer);library(rgdal)
# Download and unzip NTA file
# url <- "https://data.cityofnewyork.us/api/geospatial/d3qk-pfyz?method=export&format=Shapefile"
# download.file(url, here("downloads", "nta.zip"), mode = "wb")
# unzip(here("downloads", "nta.zip"), exdir = here("downloads"))
# Find NTA filename (changes with each DL)
file_id <- paste0("./", list.files(here("downloads"), pattern = "*.shp"))
nyc_nta <- st_read(here("downloads", file_id))
cust_pal <- palette(rep_len(c("#F3EEF3", "#BDC9DE", "#70A8D1", "#2B8DBC", "#04598F"), 195))
png(here("figures", "nyc_nta.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(nyc_nta["ntaname"],
pal = cust_pal,
border = "white", main = NULL)
dev.off()
library(sf); library(tidyverse); library(here); library(RColorBrewer)
# Before other things, compute expected classification errors
# Requires these specially formatted .csvs in online error calculator
trctVals <- read.csv(here("outputs", "ethn_trct.csv")) %>%
select(pct, moe) %>%
mutate(pct = pct * 100) %>%
drop_na()
write.csv(trctVals, here("outputs", "ethn_trct_Autoreporter.csv"), row.names = FALSE)
bgVals <- read.csv(here("outputs", "ethn_bg.csv")) %>%
select(pct, moe) %>%
mutate(pct = pct * 100) %>%
drop_na()
write.csv(bgVals, here("outputs", "ethn_bg_Autoreporter.csv"), row.names = FALSE)
# Now, for making visuals
ethnBg <- st_read(here("outputs", "./ethn_orig_bg.shp")) %>%
mutate_at(c("GEOID"), as.character) %>%
st_set_crs(4326) %>%
st_transform(26918) %>%
mutate(pct = pct * 100,
sd = moe / 1.645)
ethnTrct <- st_read(here("outputs", "./ethn_orig_trct.shp")) %>%
mutate_at(c("GEOID"), as.character) %>%
st_set_crs(4326) %>%
st_transform(26918) %>%
mutate(pct = pct * 100,
sd = moe / 1.645)
ethnCty <- st_read(here("outputs", "./ethn_orig_cty.shp")) %>%
mutate_at(c("GEOID"), as.character) %>%
st_set_crs(4326) %>%
st_transform(26918) %>%
mutate(pct = pct * 100,
sd = moe / 1.645)
# Generate random outcomes based on estimate and MOE
alternatives <- 20; idx <- ncol(ethnTrct)
for(i in 1:alternatives){
ethnTrct[i + idx] <- 0
colnames(ethnTrct)[i + idx] <- paste0("s_", i)
for (row in 1:nrow(ethnTrct)) {
normval <- rnorm(1, ethnTrct$pct[[row]], ethnTrct$sd[[row]])
ethnTrct[row, i + idx] <- ifelse(is.nan(normval), NA, normval)
}
}
# Display random outcomes with same no classes and class scheme
rand <- ethnTrct %>%
select(pct, starts_with("s_")) %>%
mutate_at(vars(s_1:s_20), funs(replace(., . < 0, 0))) %>%
mutate_at(vars(s_1:s_20), funs(replace(., . > max(pct), max(pct))))
idx <- ncol(rand) - 1
# Display random outcomes with same no classes and class scheme
rand <- ethnBg %>%
select(pct, starts_with("s_")) %>%
mutate_at(vars(s_1:s_20), funs(replace(., . < 0, 0))) %>%
mutate_at(vars(s_1:s_20), funs(replace(., . > max(pct), max(pct))))
idx <- ncol(rand) - 1
# Display random outcomes with same no classes and class scheme
rand <- ethnBg #%>%
rand
library(sf); library(tidyverse); library(here); library(RColorBrewer)
# Before other things, compute expected classification errors
# Requires these specially formatted .csvs in online error calculator
trctVals <- read.csv(here("outputs", "ethn_trct.csv")) %>%
select(pct, moe) %>%
mutate(pct = pct * 100) %>%
drop_na()
write.csv(trctVals, here("outputs", "ethn_trct_Autoreporter.csv"), row.names = FALSE)
bgVals <- read.csv(here("outputs", "ethn_bg.csv")) %>%
select(pct, moe) %>%
mutate(pct = pct * 100) %>%
drop_na()
write.csv(bgVals, here("outputs", "ethn_bg_Autoreporter.csv"), row.names = FALSE)
# Now, for making visuals
ethnBg <- st_read(here("outputs", "./ethn_orig_bg.shp")) %>%
mutate_at(c("GEOID"), as.character) %>%
st_set_crs(4326) %>%
st_transform(26918) %>%
mutate(pct = pct * 100,
sd = moe / 1.645)
ethnTrct <- st_read(here("outputs", "./ethn_orig_trct.shp")) %>%
mutate_at(c("GEOID"), as.character) %>%
st_set_crs(4326) %>%
st_transform(26918) %>%
mutate(pct = pct * 100,
sd = moe / 1.645)
ethnCty <- st_read(here("outputs", "./ethn_orig_cty.shp")) %>%
mutate_at(c("GEOID"), as.character) %>%
st_set_crs(4326) %>%
st_transform(26918) %>%
mutate(pct = pct * 100,
sd = moe / 1.645)
# Generate random outcomes based on estimate and MOE
alternatives <- 20; idx <- ncol(ethnTrct)
for(i in 1:alternatives){
ethnTrct[i + idx] <- 0
colnames(ethnTrct)[i + idx] <- paste0("s_", i)
for (row in 1:nrow(ethnTrct)) {
normval <- rnorm(1, ethnTrct$pct[[row]], ethnTrct$sd[[row]])
ethnTrct[row, i + idx] <- ifelse(is.nan(normval), NA, normval)
}
}
warnings()
# Display random outcomes with same no classes and class scheme
rand <- ethnBg %>%
select(pct, starts_with("s_")) %>%
mutate_at(vars(s_1:s_20), funs(replace(., . < 0, 0))) %>%
mutate_at(vars(s_1:s_20), funs(replace(., . > max(pct), max(pct))))
library(sf); library(tidyverse); library(here); library(RColorBrewer)
# Before other things, compute expected classification errors
# Requires these specially formatted .csvs in online error calculator
trctVals <- read.csv(here("outputs", "ethn_trct.csv")) %>%
select(pct, moe) %>%
mutate(pct = pct * 100) %>%
drop_na()
write.csv(trctVals, here("outputs", "ethn_trct_Autoreporter.csv"), row.names = FALSE)
bgVals <- read.csv(here("outputs", "ethn_bg.csv")) %>%
select(pct, moe) %>%
mutate(pct = pct * 100) %>%
drop_na()
write.csv(bgVals, here("outputs", "ethn_bg_Autoreporter.csv"), row.names = FALSE)
# Now, for making visuals
ethnBg <- st_read(here("outputs", "./ethn_orig_bg.shp")) %>%
mutate_at(c("GEOID"), as.character) %>%
st_set_crs(4326) %>%
st_transform(26918) %>%
mutate(pct = pct * 100,
sd = moe / 1.645)
ethnTrct <- st_read(here("outputs", "./ethn_orig_trct.shp")) %>%
mutate_at(c("GEOID"), as.character) %>%
st_set_crs(4326) %>%
st_transform(26918) %>%
mutate(pct = pct * 100,
sd = moe / 1.645)
ethnCty <- st_read(here("outputs", "./ethn_orig_cty.shp")) %>%
mutate_at(c("GEOID"), as.character) %>%
st_set_crs(4326) %>%
st_transform(26918) %>%
mutate(pct = pct * 100,
sd = moe / 1.645)
rm(rand)
# Generate random outcomes based on estimate and MOE
alternatives <- 20; idx <- ncol(ethnBg)
for(i in 1:alternatives){
ethnBg[i + idx] <- 0
colnames(ethnBg)[i + idx] <- paste0("s_", i)
for (row in 1:nrow(ethnBg)) {
normval <- rnorm(1, ethnBg$pct[[row]], ethnBg$sd[[row]])
ethnBg[row, i + idx] <- ifelse(is.nan(normval), NA, normval)
}
}
View(ethnBg)
# Display random outcomes with same no classes and class scheme
rand <- ethnBg %>%
select(pct, starts_with("s_")) %>%
mutate_at(vars(s_1:s_20), funs(replace(., . < 0, 0))) %>%
mutate_at(vars(s_1:s_20), funs(replace(., . > max(pct), max(pct))))
View(rand)
idx <- ncol(rand) - 1
for (i in 2:idx){
png(here("figures", paste0("rand_", i - 1, ".png")), width = 10, height = 7.5, units = "in", res = 500)
plot(rand[i], breaks = "quantile", nbreaks = 5,
pal = brewer.pal(5, "PuBu"),
border = NA, main = NULL)
dev.off()
}
# Display random outcomes with same no classes and class scheme
rand <- ethnBg %>%
select(pct, starts_with("s_")) %>%
mutate_at(vars(s_1:s_20), funs(replace(., . < 0, 0))) %>%
mutate_at(vars(s_1:s_20), funs(replace(., . > 100, 100)))
idx <- ncol(rand) - 1
View(rand)
for (i in 2:idx){
png(here("figures", paste0("rand_", i - 1, ".png")), width = 10, height = 7.5, units = "in", res = 500)
plot(rand[i], breaks = "quantile", nbreaks = 5,
pal = brewer.pal(5, "PuBu"),
border = NA, main = NULL)
dev.off()
}
