forcats::fct_relevel(cvCat, "H", "M", "L")
f <- factor(c("a", "b", "c", "d"))
fct_relevel(f, "c")
fct_relevel(f, "c", "d", "a", "b")
str(ethnTrct)
library(tidyverse); library(sf); library(here); library(magrittr)
# Does reliability change according to population, sample rate, distance from city center?
# TRACT
ethnTrct <- st_read(here("outputs", "./ethn_trct.shp")) %>%
mutate_at(c("GEOID"), as.character) %>%
st_set_crs(4326) %>%
st_transform(26918)
ethnAux <- read.csv(here("outputs", "aux_trct.csv")) %>%
mutate_at(c("GEOID"), as.character) %>%
select(-type)
ethnTrct %<>% dplyr::left_join(., ethnAux, by = "GEOID")
ethnCorr <- ethnTrct %>%
select(pct, relative, cv, landArea, popDens, popSamp, B01003_001E) %>%
st_set_geometry(NULL)
round(cor(ethnCorr, use = "pairwise.complete.obs"),3)
sampBreaks <- quantile(ethnTrct$popSamp, probs = seq(0, 1, 0.25), na.rm = TRUE)
# See http://help.arcgis.com/en/businessanalyst/apis/rest/reference/ACSVariables.html
# and https://svi.cdc.gov/Documents/Publications/CDC_ATSDR_SVI_Materials/SampleSizeError_v2.pdf
# for reliability criteria
ethnTrct %<>%
mutate(popCat = case_when(B01003_001E < 1000 ~ "Fewer than 1,000",
B01003_001E >= 1000 & B01003_001E < 3000 ~ "1,000-2,999",
B01003_001E >= 3000 & B01003_001E < 5000 ~ "3,000-4,999",
B01003_001E >= 5000 & B01003_001E < 7000 ~ "5,000-6,999",
B01003_001E >= 7000 ~ "7,000 or greater"),
popSampCat = case_when(popSamp < sampBreaks[2] ~ "Bottom Quartile",
popSamp >= sampBreaks[2] & popSamp < sampBreaks[3] ~ "Second Quartile",
popSamp >= sampBreaks[3] & popSamp < sampBreaks[4] ~ "Third Quartile",
popSamp >= sampBreaks[4] ~ "Top Quartile"),
cvCat = case_when(cv <= 12 ~ "H",
cv > 12 & cv <= 40 ~ "M",
cv > 40 ~ "L")) %>%
mutate_at(c("cvCat"), as.factor)
str(ethnTrct)
levels(ethnTrct$cvCat)
mutate_at(c("cvCat"), fct_relevel(.))
ethnTrct %<>% mutate_at(c("cvCat"), fct_relevel(.))
f <- factor("H", "M", "L")
ethnTrct %<>% mutate_at(c("cvCat"), fct_relevel(., f))
fct_relevel(levels(ethnTrct$cvCat))
fct_relevel(levels(ethnTrct$cvCat), "H", "M", "L")
fct_relevel(ethnTrct$cvCat, "H", "M", "L")
potentially <- factor("H", "M", "L")
ethnTrct %<>% mutate_at(c("cvCat"), fct_relevel(., "H", "M", "L"))
ethnTrct %<>% mutate_at(c("cvCat"), fct_relevel(levels(.), "H", "M", "L"))
library(tidyverse); library(sf); library(here); library(magrittr)
# Does reliability change according to population, sample rate, distance from city center?
# TRACT
ethnTrct <- st_read(here("outputs", "./ethn_trct.shp")) %>%
mutate_at(c("GEOID"), as.character) %>%
st_set_crs(4326) %>%
st_transform(26918)
ethnAux <- read.csv(here("outputs", "aux_trct.csv")) %>%
mutate_at(c("GEOID"), as.character) %>%
select(-type)
ethnTrct %<>% dplyr::left_join(., ethnAux, by = "GEOID")
ethnCorr <- ethnTrct %>%
select(pct, relative, cv, landArea, popDens, popSamp, B01003_001E) %>%
st_set_geometry(NULL)
round(cor(ethnCorr, use = "pairwise.complete.obs"),3)
sampBreaks <- quantile(ethnTrct$popSamp, probs = seq(0, 1, 0.25), na.rm = TRUE)
# See http://help.arcgis.com/en/businessanalyst/apis/rest/reference/ACSVariables.html
# and https://svi.cdc.gov/Documents/Publications/CDC_ATSDR_SVI_Materials/SampleSizeError_v2.pdf
# for reliability criteria
ethnTrct %<>%
mutate(popCat = case_when(B01003_001E < 1000 ~ "Fewer than 1,000",
B01003_001E >= 1000 & B01003_001E < 3000 ~ "1,000-2,999",
B01003_001E >= 3000 & B01003_001E < 5000 ~ "3,000-4,999",
B01003_001E >= 5000 & B01003_001E < 7000 ~ "5,000-6,999",
B01003_001E >= 7000 ~ "7,000 or greater"),
popSampCat = case_when(popSamp < sampBreaks[2] ~ "Bottom Quartile",
popSamp >= sampBreaks[2] & popSamp < sampBreaks[3] ~ "Second Quartile",
popSamp >= sampBreaks[3] & popSamp < sampBreaks[4] ~ "Third Quartile",
popSamp >= sampBreaks[4] ~ "Top Quartile"),
cvCat = case_when(cv <= 12 ~ "H",
cv > 12 & cv <= 40 ~ "M",
cv > 40 ~ "L")) %>%
mutate_at(c("cvCat"), as.factor)
ethnTrct %<>% mutate_at(c("cvCat"), fct_relevel(levels(.), "H", "M", "L"))
library(tidyverse); library(sf); library(here); library(magrittr)
# Does reliability change according to population, sample rate, distance from city center?
# TRACT
ethnTrct <- st_read(here("outputs", "./ethn_trct.shp")) %>%
mutate_at(c("GEOID"), as.character) %>%
st_set_crs(4326) %>%
st_transform(26918)
ethnAux <- read.csv(here("outputs", "aux_trct.csv")) %>%
mutate_at(c("GEOID"), as.character) %>%
select(-type)
ethnTrct %<>% dplyr::left_join(., ethnAux, by = "GEOID")
ethnCorr <- ethnTrct %>%
select(pct, relative, cv, landArea, popDens, popSamp, B01003_001E) %>%
st_set_geometry(NULL)
round(cor(ethnCorr, use = "pairwise.complete.obs"),3)
sampBreaks <- quantile(ethnTrct$popSamp, probs = seq(0, 1, 0.25), na.rm = TRUE)
# See http://help.arcgis.com/en/businessanalyst/apis/rest/reference/ACSVariables.html
# and https://svi.cdc.gov/Documents/Publications/CDC_ATSDR_SVI_Materials/SampleSizeError_v2.pdf
# for reliability criteria
ethnTrct %<>%
mutate(popCat = case_when(B01003_001E < 1000 ~ "Fewer than 1,000",
B01003_001E >= 1000 & B01003_001E < 3000 ~ "1,000-2,999",
B01003_001E >= 3000 & B01003_001E < 5000 ~ "3,000-4,999",
B01003_001E >= 5000 & B01003_001E < 7000 ~ "5,000-6,999",
B01003_001E >= 7000 ~ "7,000 or greater"),
popSampCat = case_when(popSamp < sampBreaks[2] ~ "Bottom Quartile",
popSamp >= sampBreaks[2] & popSamp < sampBreaks[3] ~ "Second Quartile",
popSamp >= sampBreaks[3] & popSamp < sampBreaks[4] ~ "Third Quartile",
popSamp >= sampBreaks[4] ~ "Top Quartile"),
cvCat = case_when(cv <= 12 ~ "H",
cv > 12 & cv <= 40 ~ "M",
cv > 40 ~ "L")) %>%
mutate_at(c("cvCat"), as.factor)
ethnTrct %>%
mutate_at(c("cvCat"), fct_relevel("H", "M", "L") %>% levels())
ethnTrct$cvCat %>% fct_relevel("H", "M", "L") %>% levels()
levels(ethnTrct$cvCat)
ethnTrct$cvCat <- ethnTrct$cvCat %>% fct_relevel("H", "M", "L") %>% levels()
levels(ethnTrct$cvCat) <- ethnTrct$cvCat %>% fct_relevel("H", "M", "L") %>% levels()
ethnTrct %>% group_by(popCat) %>%
summarize(cvMean = mean(cv, na.rm = TRUE),
cvMedian = median(cv, na.rm = TRUE))
# In this case, sample rate doesn't make much of a difference
ethnTrct %>% group_by(popSampCat) %>%
summarize(cvMean = mean(cv, na.rm = TRUE),
cvMedian = median(cv, na.rm = TRUE))
# But the percentage of Hispanic residents in the tract *does* make a difference
png(here("figures", "hisp_cvCat.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(ethnTrct["cvCat"], border = NA, main = NULL)
dev.off()
# ggplot this later?
plot(ethnTrct$pct, ethnTrct$cv)
ggplot(ethnTrct, aes(x = pct, y = cv)) + geom_point()
ggplot(ethnTrct, aes(x = pct, y = cv)) + geom_point() + theme_minimal()
ggplot(ethnTrct, aes(x = pct, y = cv)) + geom_point() +
geom_smooth() + theme_minimal()
ggplot(ethnTrct, aes(x = pct, y = cv)) + geom_point()
ggplot(ethnTrct, aes(x = pct, y = cv)) + geom_point() + geom_smooth()
ggplot(ethnTrct, aes(x = pct, y = cv)) + geom_point() + geom_smooth(se = FALSE)
ggplot(ethnTrct, aes(x = pct, y = cv)) + geom_point() + geom_smooth(color = "darkblue")
ggplot(ethnTrct, aes(x = pct, y = cv)) + geom_point(color = "gray") + geom_smooth(color = "darkblue")
ggplot(ethnTrct, aes(x = pct, y = cv)) +
geom_point(color = "gray") +
geom_smooth(color = "darkblue") +
labs(title = "Relationship of CV and Percentage Estimate by Tract",
x = "Pct. Estimated Hispanic Residents",
y = "Pct. CV")
ggplot(ethnTrct, aes(x = pct, y = cv)) +
geom_point(color = "gray") +
geom_smooth(color = "darkblue") +
labs(title = "Relationship of CV and Percentage Estimate by Tract",
x = "Pct. Estimated Hispanic Residents",
y = "Pct. CV") +
theme_minimal()
png(here("figures", "hisp_cvRel.png"), width = 10, height = 7.5, units = "in", res = 500)
ggplot(ethnTrct, aes(x = pct, y = cv)) +
geom_point(color = "gray") +
geom_smooth(color = "darkblue") +
labs(title = "Relationship of CV and Percentage Estimate by Tract",
x = "Pct. Estimate, Hispanic Residents",
y = "Pct. CV") +
theme_minimal()
dev.off()
library(tidyverse); library(sf); library(here); library(magrittr); library(RColorBrewer)
# Does reliability change according to population, sample rate, distance from city center?
ethnTrct <- st_read(here("outputs", "./ethn_trct.shp")) %>%
mutate_at(c("GEOID"), as.character) %>%
st_set_crs(4326) %>%
st_transform(26918)
ethnAux <- read.csv(here("outputs", "aux_trct.csv")) %>%
mutate_at(c("GEOID"), as.character) %>%
select(-type)
ethnTrct %<>% dplyr::left_join(., ethnAux, by = "GEOID")
ethnCorr <- ethnTrct %>%
select(pct, relative, cv, landArea, popDens, popSamp, B01003_001E) %>%
st_set_geometry(NULL)
round(cor(ethnCorr, use = "pairwise.complete.obs"),3)
sampBreaks <- quantile(ethnTrct$popSamp, probs = seq(0, 1, 0.25), na.rm = TRUE)
# See http://help.arcgis.com/en/businessanalyst/apis/rest/reference/ACSVariables.html
# and https://svi.cdc.gov/Documents/Publications/CDC_ATSDR_SVI_Materials/SampleSizeError_v2.pdf
# for reliability criteria
ethnTrct %<>%
mutate(popCat = case_when(B01003_001E < 1000 ~ "Fewer than 1,000",
B01003_001E >= 1000 & B01003_001E < 3000 ~ "1,000-2,999",
B01003_001E >= 3000 & B01003_001E < 5000 ~ "3,000-4,999",
B01003_001E >= 5000 & B01003_001E < 7000 ~ "5,000-6,999",
B01003_001E >= 7000 ~ "7,000 or greater"),
popSampCat = case_when(popSamp < sampBreaks[2] ~ "Bottom Quartile",
popSamp >= sampBreaks[2] & popSamp < sampBreaks[3] ~ "Second Quartile",
popSamp >= sampBreaks[3] & popSamp < sampBreaks[4] ~ "Third Quartile",
popSamp >= sampBreaks[4] ~ "Top Quartile"),
cvCat = case_when(cv <= 12 ~ "H",
cv > 12 & cv <= 40 ~ "M",
cv > 40 ~ "L")) %>%
mutate_at(c("cvCat"), as.factor)
levels(ethnTrct$cvCat) <- ethnTrct$cvCat %>% fct_relevel("H", "M", "L") %>% levels()
# Smaller pop have less reliability
ethnTrct %>% group_by(popCat) %>%
summarize(cvMean = mean(cv, na.rm = TRUE),
cvMedian = median(cv, na.rm = TRUE))
# In this case, sample rate doesn't make much of a difference
ethnTrct %>% group_by(popSampCat) %>%
summarize(cvMean = mean(cv, na.rm = TRUE),
cvMedian = median(cv, na.rm = TRUE))
# But the percentage of Hispanic residents in the tract *does* make a difference
custom <- c("#8CAE68", "#F1EEF5", "#DFBF9F")
png(here("figures", "hisp_cvCat.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(ethnTrct["cvCat"],
pal = custom,
border = NA, main = NULL)
dev.off()
png(here("figures", "hisp_pct.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(ethnTrct["pct"], nbreaks = 5,
pal = brewer.pal(5, "PuBu"),
border = NA, main = NULL)
dev.off()
cor(ethnTrct$pct, ethnTrct$cv)
png(here("figures", "hisp_cvRel.png"), width = 10, height = 7.5, units = "in", res = 500)
ggplot(ethnTrct, aes(x = pct, y = cv)) +
geom_point(color = "gray") +
geom_smooth(color = "#289BBE") +
labs(title = "Relationship of CV and Percentage Estimate by Tract",
x = "Pct. Estimate, Hispanic Residents",
y = "Pct. CV") +
theme_minimal()
dev.off()
# Before other things, compute expected classification errors
library(sf); library(tidyverse); library(here); library(RColorBrewer)
# Now, for making visuals
ethnBg <- st_read(here("outputs", "./ethn_orig_bg.shp")) %>%
mutate_at(c("GEOID"), as.character) %>%
st_set_crs(4326) %>%
st_transform(26918) %>%
mutate(pct = pct * 100,
sd = moe / 1.645)
ethnTrct <- st_read(here("outputs", "./ethn_orig_trct.shp")) %>%
mutate_at(c("GEOID"), as.character) %>%
st_set_crs(4326) %>%
st_transform(26918) %>%
mutate(pct = pct * 100,
sd = moe / 1.645)
ethnCty <- st_read(here("outputs", "./ethn_orig_cty.shp")) %>%
mutate_at(c("GEOID"), as.character) %>%
st_set_crs(4326) %>%
st_transform(26918) %>%
mutate(pct = pct * 100,
sd = moe / 1.645)
# Generate random outcomes based on estimate and MOE
alternatives <- 20; idx <- ncol(ethnTrct)
for(i in 1:alternatives){
ethnTrct[i + idx] <- 0
colnames(ethnTrct)[i + idx] <- paste0("s_", i)
for (row in 1:nrow(ethnTrct)) {
normval <- rnorm(1, ethnTrct$pct[[row]], ethnTrct$sd[[row]])
ethnTrct[row, i + idx] <- ifelse(is.nan(normval), NA, normval)
}
}
# Display random outcomes with same no classes and class scheme
rand <- ethnTrct %>%
select(pct, starts_with("s_")) %>%
mutate_at(vars(s_1:s_20), funs(replace(., . < 0, 0))) %>%
mutate_at(vars(s_1:s_20), funs(replace(., . > max(pct), max(pct))))
idx <- ncol(rand) - 1
eBreaks <- seq(min(rand$pct, na.rm = TRUE),
max(rand$pct, na.rm = TRUE),
length.out = 5)
eBreaks[1] <- 0; eBreaks[5] <- 100
for (i in 2:idx){
png(here("figures", paste0("rand_", i - 1, ".png")), width = 10, height = 7.5, units = "in", res = 500)
plot(rand[i], breaks = eBreaks,
pal = brewer.pal(4, "PuBu"),
border = NA, main = NULL)
dev.off()
}
# Number of classes
# Overall = overall map error for the scheme
# Max class = maximum expected classification error for a single class
error_class <- c(#"0.6% Overall Map Error, 5.5% Max. Class Error",
"1.7% Overall Map Error, 20.3% Max. Class Error",
"2.9% Overall Map Error, 21.5% Max. Class Error",
"4.5% Overall Map Error, 29.8% Max. Class Error",
"6.2% Overall Map Error, 33.2% Max. Class Error",
"8.2% Overall Map Error, 40.4% Max. Class Error")
for (j in 3:7){
# We use j + 1 because seq includes minimum and maximum
eBreaks <- seq(min(ethnTrct$pct, na.rm = TRUE),
max(ethnTrct$pct, na.rm = TRUE),
length.out = j + 1)
png(here("figures", paste0("cn_", j, ".png")), width = 10, height = 7.5, units = "in", res = 500)
plot(ethnTrct["pct"], breaks = eBreaks,
pal = brewer.pal(j, "PuBu"),
border = NA, main = error_class[j - 2])
dev.off()
}
# Classification scheme
error_class <- c("17.3% Overall Map Error, 31.2% Max. Class Error",
"37.2% Overall Map Error, 57.9% Max. Class Error",
"4.5% Overall Map Error, 29.8% Max. Class Error")
png(here("figures", "cb_jenks.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(ethnTrct["pct"], breaks = "jenks", nbreaks = 5,
pal = brewer.pal(5, "PuBu"),
border = NA, main = error_class[1])
dev.off()
png(here("figures", "cb_quantile.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(ethnTrct["pct"], breaks = "quantile", nbreaks = 5,
pal = brewer.pal(5, "PuBu"),
border = NA, main = error_class[1])
dev.off()
png(here("figures", "cb_equal.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(ethnTrct["pct"], breaks = "equal", nbreaks = 5,
pal = brewer.pal(5, "PuBu"),
border = NA, main = error_class[1])
dev.off()
# Geography selected
error_class <- c("4.5% Overall Map Error, 29.8% Max. Class Error",
"10.9% Overall Map Error, 49.8% Max. Class Error")
png(here("figures", "geo_trct.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(ethnTrct["pct"], breaks = "equal", nbreaks = 5,
pal = brewer.pal(5, "PuBu"),
border = NA, main = error_class[1])
dev.off()
png(here("figures", "geo_bg.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(ethnBg["pct"], breaks = "equal", nbreaks = 5,
pal = brewer.pal(5, "PuBu"),
border = NA, main = error_class[2])
dev.off()
error_class <- c("17.3% Overall Map Error, 31.2% Max. Class Error",
"37.2% Overall Map Error, 57.9% Max. Class Error",
"4.5% Overall Map Error, 29.8% Max. Class Error")
png(here("figures", "cb_jenks.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(ethnTrct["pct"], breaks = "jenks", nbreaks = 5,
pal = brewer.pal(5, "PuBu"),
border = NA, main = error_class[1])
dev.off()
png(here("figures", "cb_quantile.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(ethnTrct["pct"], breaks = "quantile", nbreaks = 5,
pal = brewer.pal(5, "PuBu"),
border = NA, main = error_class[2])
dev.off()
png(here("figures", "cb_equal.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(ethnTrct["pct"], breaks = "equal", nbreaks = 5,
pal = brewer.pal(5, "PuBu"),
border = NA, main = error_class[3])
dev.off()
library(here); library(tidyverse)
bottom <- read.csv(here("outputs", "ex_b.csv"))
middle <- read.csv(here("outputs", "ex_m.csv"))
top <- read.csv(here("outputs", "ex_t.csv"))
# Define plot colors
main = "#298BBE"
secondary = "#0E5795"
bottom <- read.csv(here("outputs", "ex_b.csv"))
middle <- read.csv(here("outputs", "ex_m.csv"))
top <- read.csv(here("outputs", "ex_t.csv"))
# Define plot colors
main = "#298BBE"
secondary = "#0E5795"
# Single estimate
p1 <- ggplot(data = data.frame(x = c(-10, 110)), aes(x)) +
stat_function(fun = dnorm, n = 101, color = main,
args = list(mean = top[1,]$pct, sd = top[1,]$sd)) + ylab("") +
scale_y_continuous(breaks = NULL) +
ylab("Probability") + xlab("Potential Value of Estimate") +
ggtitle("Range of Possible Values for One Census Tract") +
theme_minimal()
# Single estimate with class boundary
p2 <- ggplot(data = data.frame(x = c(-10, 110)), aes(x)) +
stat_function(fun = dnorm, n = 101, color = main,
args = list(mean = top[1,]$pct, sd = top[1,]$sd)) + ylab("") +
scale_y_continuous(breaks = NULL) +
annotate("segment", x = 200 / 3, xend = 200 / 3, y = 0.1, yend = 0, color = "gray") +
ylab("Probability") + xlab("Potential Value of Estimate") +
ggtitle("Range of Possible Values for One Census Tract") +
theme_minimal()
# Single estimate with classification error
p3 <- ggplot(data = data.frame(x = c(-10, 110)), aes(x)) +
stat_function(fun = dnorm, n = 101, color = main,
args = list(mean = top[1,]$pct, sd = top[1,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = main, alpha = 0.3,
args = list(mean = top[1,]$pct, sd = top[1,]$sd),
xlim = c(0, 200 / 3),
geom = "area") +
ylab("Probability") + xlab("Potential Value of Estimate") +
ggtitle("Range of Possible Values for One Census Tract") +
theme_minimal() +
annotate("segment", x = 200 / 3, xend = 200 / 3, y = 0.1, yend = 0, color = "gray")
# Two estimates with class boundary
p4 <- ggplot(data = data.frame(x = c(-10, 110)), aes(x)) +
stat_function(fun = dnorm, n = 101, color = main,
args = list(mean = top[1,]$pct, sd = top[1,]$sd)) +
stat_function(fun = dnorm, n = 101, color = secondary,
args = list(mean = top[2,]$pct, sd = top[2,]$sd)) +
ylab("Probability") + xlab("Potential Value of Estimate") +
scale_y_continuous(breaks = NULL) +
ggtitle("Range of Possible Values for Two Census Tracts") +
theme_minimal() +
annotate("segment", x = 200 / 3, xend = 200 / 3, y = 0.1, yend = 0, color = "gray")
# Two estimates with class boundary and classification error
p5 <- ggplot(data = data.frame(x = c(-10, 110)), aes(x)) +
stat_function(fun = dnorm, n = 101, color = main,
args = list(mean = top[1,]$pct, sd = top[1,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = main, alpha = 0.3,
args = list(mean = top[1,]$pct, sd = top[1,]$sd),
xlim = c(0, 200 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = secondary,
args = list(mean = top[2,]$pct, sd = top[2,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = secondary, alpha = 0.3,
args = list(mean = top[2,]$pct, sd = top[2,]$sd),
xlim = c(0, 200 / 3),
geom = "area") +
ylab("Probability") + xlab("Potential Value of Estimate") +
scale_y_continuous(breaks = NULL) +
ggtitle("Range of Possible Values for Two Census Tracts") +
theme_minimal() +
annotate("segment", x = 200 / 3, xend = 200 / 3, y = 0.1, yend = 0, color = "gray")
# All estimates with boundaries and classification error
# Two estimates with class boundary and classification error
p6 <- ggplot(data = data.frame(x = c(-10, 110)), aes(x)) +
stat_function(fun = dnorm, n = 101, color = main,
args = list(mean = top[1,]$pct, sd = top[1,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = main, alpha = 0.3,
args = list(mean = top[1,]$pct, sd = top[1,]$sd),
xlim = c(0, 200 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = main,
args = list(mean = top[2,]$pct, sd = top[2,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = main, alpha = 0.3,
args = list(mean = top[2,]$pct, sd = top[2,]$sd),
xlim = c(0, 200 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = main,
args = list(mean = top[3,]$pct, sd = top[3,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = main, alpha = 0.3,
args = list(mean = top[3,]$pct, sd = top[3,]$sd),
xlim = c(0, 200 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = main,
args = list(mean = middle[1,]$pct, sd = middle[1,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = main, alpha = 0.3,
args = list(mean = middle[1,]$pct, sd = middle[1,]$sd),
xlim = c(0, 100 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, fill = main, alpha = 0.3,
args = list(mean = middle[1,]$pct, sd = middle[1,]$sd),
xlim = c(200 / 3, 100),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = main,
args = list(mean = middle[2,]$pct, sd = middle[2,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = main, alpha = 0.3,
args = list(mean = middle[2,]$pct, sd = middle[2,]$sd),
xlim = c(0, 100 / 3),
geom = "area") +
stat_function(fun = dnorm, n = 101, fill = main, alpha = 0.3,
args = list(mean = middle[2,]$pct, sd = middle[2,]$sd),
xlim = c(200 / 3, 100),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = main,
args = list(mean = bottom[1,]$pct, sd = bottom[1,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = main, alpha = 0.3,
args = list(mean = bottom[1,]$pct, sd = bottom[1,]$sd),
xlim = c(100 / 3, 100),
geom = "area") +
stat_function(fun = dnorm, n = 101, color = main,
args = list(mean = bottom[2,]$pct, sd = bottom[2,]$sd)) +
stat_function(fun = dnorm, n = 101, fill = main, alpha = 0.3,
args = list(mean = bottom[2,]$pct, sd = bottom[2,]$sd),
xlim = c(100 / 3, 100),
geom = "area") +
ylab("Probability") + xlab("Potential Value of Estimate") +
scale_y_continuous(breaks = NULL) +
ggtitle("Range of Possible Values for All Census Tracts") +
theme_minimal()
# Compute errors
# Bottom class error
bc_1 <- pnorm(100 / 3, bottom[1,]$pct, bottom[1,]$sd, lower.tail = FALSE) * 100
bc_2 <- pnorm(100 / 3, bottom[2,]$pct, bottom[2,]$sd, lower.tail = FALSE) * 100
bc_mean <- (bc_1 + bc_2) / 2
# Middle class error
mc_1 <- (pnorm(100 / 3, middle[1,]$pct, middle[1,]$sd) +
pnorm(200 / 3, middle[1,]$pct, middle[1,]$sd, lower.tail = FALSE)) * 100
mc_2 <- (pnorm(100 / 3, middle[2,]$pct, middle[2,]$sd) +
pnorm(200 / 3, middle[2,]$pct, middle[2,]$sd, lower.tail = FALSE)) * 100
mc_mean <- (mc_1 + mc_2) / 2
# Top class error
tc_1 <- pnorm(200 / 3, top[1,]$pct, top[1,]$sd) * 100
tc_2 <- pnorm(200 / 3, top[2,]$pct, top[2,]$sd) * 100
tc_3 <- pnorm(200 / 3, top[3,]$pct, top[2,]$sd) * 100
tc_mean <- (tc_1 + tc_2 + tc_3) / 3
tot_mean <- ((bc_mean * 2) + (mc_mean * 2) + (tc_mean * 3)) / 7
png(here("figures", "p1.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(p1)
dev.off()
png(here("figures", "p2.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(p2)
dev.off()
png(here("figures", "p3.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(p3)
dev.off()
png(here("figures", "p4.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(p4)
dev.off()
png(here("figures", "p5.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(p5)
dev.off()
png(here("figures", "p6.png"), width = 10, height = 7.5, units = "in", res = 500)
plot(p6)
dev.off()
